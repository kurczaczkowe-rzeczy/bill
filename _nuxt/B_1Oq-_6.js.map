{"version":3,"file":"B_1Oq-_6.js","sources":["../../../../../../.pnpm/perfect-debounce@1.0.0/node_modules/perfect-debounce/dist/index.mjs","../../../../../../.pnpm/nuxt@4.0.1_@biomejs+biome@2.2.0_@netlify+blobs@9.1.2_@parcel+watcher@2.5.1_@types+node@_a12e102bfe69b053a3ca88e34846b35e/node_modules/nuxt/dist/app/composables/asyncData.js","../../../../../../../app/utils/isNil.ts","../../../../../../../app/composables/useOptimisticUpdatedList.ts","../../../../../../../app/constants.ts","../../../../../../../app/utils/channelAction.ts","../../../../../../../app/utils/assertValueIsDefined.ts","../../../../../../../app/utils/ktListToArray.ts","../../../../../../../app/utils/ktLongToNumber.ts","../../../../../../../app/utils/ktToJs.ts","../../../../../../../app/utils/handleResponseError.ts","../../../../../../../app/utils/handleResponseSuccess.ts","../../../../../../../app/utils/readResponse.ts"],"sourcesContent":["const DEBOUNCE_DEFAULTS = {\n  trailing: true\n};\nfunction debounce(fn, wait = 25, options = {}) {\n  options = { ...DEBOUNCE_DEFAULTS, ...options };\n  if (!Number.isFinite(wait)) {\n    throw new TypeError(\"Expected `wait` to be a finite number\");\n  }\n  let leadingValue;\n  let timeout;\n  let resolveList = [];\n  let currentPromise;\n  let trailingArgs;\n  const applyFn = (_this, args) => {\n    currentPromise = _applyPromised(fn, _this, args);\n    currentPromise.finally(() => {\n      currentPromise = null;\n      if (options.trailing && trailingArgs && !timeout) {\n        const promise = applyFn(_this, trailingArgs);\n        trailingArgs = null;\n        return promise;\n      }\n    });\n    return currentPromise;\n  };\n  return function(...args) {\n    if (currentPromise) {\n      if (options.trailing) {\n        trailingArgs = args;\n      }\n      return currentPromise;\n    }\n    return new Promise((resolve) => {\n      const shouldCallNow = !timeout && options.leading;\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        timeout = null;\n        const promise = options.leading ? leadingValue : applyFn(this, args);\n        for (const _resolve of resolveList) {\n          _resolve(promise);\n        }\n        resolveList = [];\n      }, wait);\n      if (shouldCallNow) {\n        leadingValue = applyFn(this, args);\n        resolve(leadingValue);\n      } else {\n        resolveList.push(resolve);\n      }\n    });\n  };\n}\nasync function _applyPromised(fn, _this, args) {\n  return await fn.apply(_this, args);\n}\n\nexport { debounce };\n","import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, nextTick, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, toValue, unref, watch } from \"vue\";\nimport { captureStackTrace } from \"errx\";\nimport { debounce } from \"perfect-debounce\";\nimport { hash } from \"ohash\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { clientOnlySymbol } from \"../components/client-only.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData } from \"#build/nuxt.config.mjs\";\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  let [_key, _handler, options = {}] = args;\n  const key = computed(() => toValue(_key));\n  if (typeof key.value !== \"string\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  options.server ??= true;\n  options.default ??= getDefault;\n  options.getCachedData ??= getDefaultCachedData;\n  options.lazy ??= false;\n  options.immediate ??= true;\n  options.deep ??= asyncDataDefaults.deep;\n  options.dedupe ??= \"cancel\";\n  const functionName = options._functionName || \"useAsyncData\";\n  const currentData = nuxtApp._asyncData[key.value];\n  if (isDev && currentData) {\n    const warnings = [];\n    const values = createHash(_handler, options);\n    if (values.handler !== currentData._hash?.handler) {\n      warnings.push(`different handler`);\n    }\n    for (const opt of [\"transform\", \"pick\", \"getCachedData\"]) {\n      if (values[opt] !== currentData._hash[opt]) {\n        warnings.push(`different \\`${opt}\\` option`);\n      }\n    }\n    if (currentData._default.toString() !== options.default.toString()) {\n      warnings.push(`different \\`default\\` value`);\n    }\n    if (options.deep && isShallow(currentData.data)) {\n      warnings.push(`mismatching \\`deep\\` option`);\n    }\n    if (warnings.length) {\n      const distURL = import.meta.url.replace(/\\/app\\/.*$/, \"/app\");\n      const { source, line, column } = captureStackTrace().find((entry) => !entry.source.startsWith(distURL)) ?? {};\n      const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\n      console.warn(`[nuxt] [${functionName}] Incompatible options detected for \"${key.value}\"${explanation}:\n${warnings.map((w) => `- ${w}`).join(\"\\n\")}\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`);\n    }\n  }\n  const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\n  if (!nuxtApp._asyncData[key.value]?._init) {\n    initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: \"initial\" });\n    nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);\n  }\n  const asyncData = nuxtApp._asyncData[key.value];\n  asyncData._deps++;\n  const initialFetch = () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    let unregister = function(key2) {\n      const data = nuxtApp._asyncData[key2];\n      if (data?._deps) {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      }\n    };\n    const instance = getCurrentInstance();\n    if (instance && fetchOnServer && options.immediate && !instance.sp) {\n      instance.sp = [];\n    }\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      onBeforeMount(() => {\n        cbs.forEach((cb) => {\n          cb();\n        });\n        cbs.splice(0, cbs.length);\n      });\n      onUnmounted(() => cbs.splice(0, cbs.length));\n    }\n    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false));\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || asyncData.data.value !== void 0)) {\n      if (pendingWhenIdle) {\n        asyncData.pending.value = false;\n      }\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (!isWithinClientOnly && nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate && asyncData.status.value !== \"success\") {\n      initialFetch();\n    }\n    const hasScope = getCurrentScope();\n    const unsubExecute = watch([key, ...options.watch || []], ([newKey], [oldKey]) => {\n      if ((newKey || oldKey) && newKey !== oldKey) {\n        const hasRun = nuxtApp._asyncData[oldKey]?.data.value !== void 0;\n        const isRunning = nuxtApp._asyncDataPromises[oldKey] !== void 0;\n        if (oldKey) {\n          unregister(oldKey);\n        }\n        const initialFetchOptions2 = { cause: \"initial\", dedupe: options.dedupe };\n        if (!nuxtApp._asyncData[newKey]?._init) {\n          let value;\n          if (oldKey && hasRun) {\n            value = nuxtApp._asyncData[oldKey]?.data.value;\n          } else {\n            value = options.getCachedData(newKey, nuxtApp, { cause: \"initial\" });\n            initialFetchOptions2.cachedData = value;\n          }\n          nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, value);\n        }\n        nuxtApp._asyncData[newKey]._deps++;\n        if (options.immediate || hasRun || isRunning) {\n          nuxtApp._asyncData[newKey].execute(initialFetchOptions2);\n        }\n      } else {\n        asyncData._execute({ cause: \"watch\", dedupe: options.dedupe });\n      }\n    }, { flush: \"sync\" });\n    if (hasScope) {\n      onScopeDispose(() => {\n        unsubExecute();\n        unregister(key.value);\n      });\n    }\n  }\n  const asyncReturn = {\n    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),\n    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),\n    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),\n    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),\n    refresh: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    execute: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    clear: () => clearNuxtDataByKey(nuxtApp, key.value)\n  };\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);\n  Object.assign(asyncDataPromise, asyncReturn);\n  return asyncDataPromise;\n}\nfunction writableComputedRef(getter) {\n  return computed({\n    get() {\n      return getter()?.value;\n    },\n    set(value) {\n      const ref2 = getter();\n      if (ref2) {\n        ref2.value = value;\n      }\n    }\n  });\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nfunction _isAutoKeyNeeded(keyOrFetcher, fetcher) {\n  if (typeof keyOrFetcher === \"string\") {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"object\" && keyOrFetcher !== null) {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"function\" && typeof fetcher === \"function\") {\n    return false;\n  }\n  return true;\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (nuxtApp._asyncData[key]) {\n    const data = nuxtApp._asyncData[key];\n    data._deps++;\n    if (getCurrentScope()) {\n      onScopeDispose(() => {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      });\n    }\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = void 0;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = unref(nuxtApp._asyncData[key]._default());\n    nuxtApp._asyncData[key].error.value = void 0;\n    if (pendingWhenIdle) {\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    if (nuxtApp._asyncDataPromises[key]) {\n      nuxtApp._asyncDataPromises[key].cancelled = true;\n    }\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\nconst isDev = import.meta.dev;\nfunction createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {\n  nuxtApp.payload._errors[key] ??= void 0;\n  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = Promise.resolve().then(() => nuxtApp.runWithContext(() => _handler(nuxtApp)));\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const _ref = options.deep ? ref : shallowRef;\n  const hasCachedData = initialCachedData !== void 0;\n  const unsubRefreshAsyncData = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n    if (!keys || keys.includes(key)) {\n      await asyncData.execute({ cause: \"refresh:hook\" });\n    }\n  });\n  const asyncData = {\n    data: _ref(hasCachedData ? initialCachedData : options.default()),\n    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === \"pending\"),\n    error: toRef(nuxtApp.payload._errors, key),\n    status: shallowRef(\"idle\"),\n    execute: (...args) => {\n      const [_opts, newValue = void 0] = args;\n      const opts = _opts && newValue === void 0 && typeof _opts === \"object\" ? _opts : {};\n      if (import.meta.dev && newValue !== void 0 && (!_opts || typeof _opts !== \"object\")) {\n        console.warn(`[nuxt] [${options._functionName}] Do not pass \\`execute\\` directly to \\`watch\\`. Instead, use an inline function, such as \\`watch(q, () => execute())\\`.`);\n      }\n      if (nuxtApp._asyncDataPromises[key]) {\n        if ((opts.dedupe ?? options.dedupe) === \"defer\") {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        nuxtApp._asyncDataPromises[key].cancelled = true;\n      }\n      if (granularCachedData || opts.cause === \"initial\" || nuxtApp.isHydrating) {\n        const cachedData = \"cachedData\" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? \"refresh:manual\" });\n        if (cachedData !== void 0) {\n          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;\n          asyncData.error.value = void 0;\n          asyncData.status.value = \"success\";\n          return Promise.resolve(cachedData);\n        }\n      }\n      if (pendingWhenIdle) {\n        asyncData.pending.value = true;\n      }\n      asyncData.status.value = \"pending\";\n      const promise = new Promise(\n        (resolve, reject) => {\n          try {\n            resolve(handler(nuxtApp));\n          } catch (err) {\n            reject(err);\n          }\n        }\n      ).then(async (_result) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        let result = _result;\n        if (options.transform) {\n          result = await options.transform(_result);\n        }\n        if (options.pick) {\n          result = pick(result, options.pick);\n        }\n        if (import.meta.dev && import.meta.server && typeof result === \"undefined\") {\n          const stack = captureStackTrace();\n          const { source, line, column } = stack[stack.length - 1] ?? {};\n          const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\n          console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}${explanation}\\` must return a value (it should not be \\`undefined\\`) or the request may be duplicated on the client side.`);\n        }\n        nuxtApp.payload.data[key] = result;\n        asyncData.data.value = result;\n        asyncData.error.value = void 0;\n        asyncData.status.value = \"success\";\n      }).catch((error) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        asyncData.error.value = createError(error);\n        asyncData.data.value = unref(options.default());\n        asyncData.status.value = \"error\";\n      }).finally(() => {\n        if (promise.cancelled) {\n          return;\n        }\n        if (pendingWhenIdle) {\n          asyncData.pending.value = false;\n        }\n        delete nuxtApp._asyncDataPromises[key];\n      });\n      nuxtApp._asyncDataPromises[key] = promise;\n      return nuxtApp._asyncDataPromises[key];\n    },\n    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),\n    _default: options.default,\n    _deps: 0,\n    _init: true,\n    _hash: isDev ? createHash(_handler, options) : void 0,\n    _off: () => {\n      unsubRefreshAsyncData();\n      if (nuxtApp._asyncData[key]?._init) {\n        nuxtApp._asyncData[key]._init = false;\n      }\n      if (purgeCachedData && !hasCustomGetCachedData) {\n        nextTick(() => {\n          if (!nuxtApp._asyncData[key]?._init) {\n            clearNuxtDataByKey(nuxtApp, key);\n            asyncData.execute = () => Promise.resolve();\n          }\n        });\n      }\n    }\n  };\n  return asyncData;\n}\nconst getDefault = () => void 0;\nconst getDefaultCachedData = (key, nuxtApp, ctx) => {\n  if (nuxtApp.isHydrating) {\n    return nuxtApp.payload.data[key];\n  }\n  if (ctx.cause !== \"refresh:manual\" && ctx.cause !== \"refresh:hook\") {\n    return nuxtApp.static.data[key];\n  }\n};\nfunction createHash(_handler, options) {\n  return {\n    handler: hash(_handler),\n    transform: options.transform ? hash(options.transform) : void 0,\n    pick: options.pick ? hash(options.pick) : void 0,\n    getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0\n  };\n}\n","export const isNil = (value: unknown): value is null | undefined =>\n  value === null || value === undefined;\n","import type { ChannelAction } from \"~/utils/channelAction\";\nimport { isNil } from \"~/utils/isNil\";\n\ntype Id = number | bigint;\n\ninterface Item {\n  id: Id;\n}\ntype WithOnlyRequiredId<T> = T extends Item ? Partial<Omit<T, \"id\">> & Item : never;\n\nexport function useOptimisticUpdatedList<ListItem extends Item>(\n  data: MaybeRefOrGetter<ListItem[] | undefined>,\n) {\n  const listToSync = ref<ListItem[]>([]);\n  const disableAction = ref(new Map<Id, ChannelAction[]>());\n\n  function blockAction(id: Id, action: ChannelAction) {\n    if (disableAction.value.has(id)) {\n      const actions = disableAction.value.get(id) as ChannelAction[];\n      actions.push(action);\n      return;\n    }\n\n    disableAction.value.set(id, [action]);\n  }\n\n  function releaseAction(id: Id, action: ChannelAction) {\n    if (!disableAction.value.has(id)) {\n      return;\n    }\n\n    const actions = disableAction.value\n      .get(id)\n      ?.filter((_action) => _action !== action) as ChannelAction[];\n\n    if (actions.length === 0) {\n      disableAction.value.delete(id);\n      return;\n    }\n\n    disableAction.value.set(id, actions);\n  }\n\n  function hasAction(action: ChannelAction): boolean {\n    const channelActionsIterator = disableAction.value.values();\n\n    let channelActions = channelActionsIterator.next().value;\n    while (channelActions !== undefined) {\n      if (channelActions.includes(action)) {\n        return true;\n      }\n      channelActions = channelActionsIterator.next().value;\n    }\n\n    return false;\n  }\n\n  function isActionBlocked(id: Id, action: ChannelAction): boolean {\n    // ToDo: Workaround for insert action. If I don't block it, it will be inserted twice'\n    if (!disableAction.value.has(id) && hasAction(\"insert\")) {\n      return true;\n    }\n\n    if (!disableAction.value.has(id)) {\n      return false;\n    }\n\n    const actions = disableAction.value.get(id) as ChannelAction[];\n    return actions.includes(action);\n  }\n\n  /* ToDo: Handle block/release action for promises\n   * function handleManageAction(id: number, action: ChannelAction, promise: Promise<any>) {}\n   * */\n\n  function getItem(id?: Id | null): { item?: ListItem; index: number } {\n    const index = getItemIndex(id);\n\n    return {\n      item: listToSync.value?.[index] as ListItem,\n      index,\n    };\n  }\n\n  function getItemIndex(id?: Id | null): number {\n    return listToSync.value?.findIndex((p) => p.id === id) ?? -1;\n  }\n\n  function upsertItem(\n    item?: WithOnlyRequiredId<ListItem> | null,\n    index?: number,\n    overwrite?: boolean,\n  ) {\n    if (isNil(item)) {\n      throw new Error(\"Invalid product\");\n    }\n\n    const foundItemIndex = getItemIndex(item.id);\n    const itemIndex = !isNil(index) && index > -1 ? index : foundItemIndex;\n\n    if (itemIndex === -1) {\n      // biome-ignore lint/suspicious/noExplicitAny: In this case it's ok'\n      return listToSync.value.push(item as any) - 1;\n    }\n\n    const deletedCount = foundItemIndex > -1 || overwrite ? 1 : 0;\n    const itemToInsert = deletedCount > 0 ? { ...listToSync.value[foundItemIndex], ...item } : item;\n\n    // biome-ignore lint/suspicious/noExplicitAny: In this case it's ok'\n    listToSync.value.splice(itemIndex, deletedCount, itemToInsert as any);\n\n    return itemIndex;\n  }\n\n  function deleteItem(id?: Id | null) {\n    const itemId = getItemIndex(id);\n    if (itemId !== -1) {\n      listToSync.value.splice(itemId, 1);\n    }\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: In this case it's ok'\n  watch(data as any, (newData) => {\n    const evaluatedData = toValue(newData);\n    if (evaluatedData) {\n      listToSync.value = evaluatedData;\n    }\n  });\n\n  return {\n    listToSync,\n    getItem,\n    getItemIndex,\n    upsertItem,\n    deleteItem,\n    blockAction,\n    releaseAction,\n    isActionBlocked,\n  };\n}\n","import { CategoryClient, ProductClient, ShoppingListClient } from \"@bill/Bill-shoppingList\";\n\nexport const shoppingListClient = new ShoppingListClient();\nexport const productClient = new ProductClient();\nexport const categoryClient = new CategoryClient();\n","import type { JsPostgresAction } from \"@bill/Bill-shoppingList\";\n\nimport { isNil } from \"~/utils/isNil\";\n\nexport const CHANNEL_ACTION = {\n  UPDATE: \"update\",\n  INSERT: \"insert\",\n  DELETE: \"delete\",\n} as const;\n\nexport type Enum<EnumLike> = EnumLike[keyof EnumLike];\n\nexport type ChannelAction = Enum<typeof CHANNEL_ACTION>;\n\nexport function getChannelActionFrom<Record, OldRecord>(\n  payload: JsPostgresAction<Record, OldRecord>,\n): ChannelAction {\n  if (!isNil(payload.record) && isNil(payload.oldRecord)) {\n    return CHANNEL_ACTION.INSERT;\n  }\n  if (!isNil(payload.record) && !isNil(payload.oldRecord)) {\n    return CHANNEL_ACTION.UPDATE;\n  }\n  if (isNil(payload.record) && !isNil(payload.oldRecord)) {\n    return CHANNEL_ACTION.DELETE;\n  }\n  throw new Error(\"Unknown channel action\");\n}\n","export function assertValueIsDefined<T>(value: T | undefined | null): asserts value is T {\n  if (value === undefined || value === null) {\n    throw new Error(\"value is undefined or null\");\n  }\n}\n","import { assertValueIsDefined } from \"~/utils/assertValueIsDefined\";\n\nexport function ktListToArray<Item>(list?: KtList<Item>): Item[] {\n  assertValueIsDefined(list);\n\n  if (isKtList(list)) {\n    return list.toArray?.() ?? [];\n  }\n\n  throw new Error(\"value is not a KtList type\");\n}\n\nexport function isKtList<T>(value: unknown): value is KtList<T> {\n  return !!value && typeof value === \"object\" && \"toArray\" in value && !!value.toArray;\n}\n\nexport interface KtList<T> {\n  toArray?: () => T[];\n  asJsReadonlyArrayView?: () => readonly T[];\n}\n","import { assertValueIsDefined } from \"~/utils/assertValueIsDefined\";\n\nexport function ktLongToNumber(long: unknown) {\n  assertValueIsDefined(long);\n\n  if (isKtLong(long)) {\n    return long.valueOf() as number;\n  }\n\n  throw new Error(\"value is not a Long type\");\n}\n\nexport function isKtLong(value: unknown): value is KtLong {\n  return !!value && typeof value === \"object\" && \"low_1\" in value && \"high_1\" in value;\n}\n\nexport interface KtLong {\n  low_1: number;\n  high_1: number;\n  toValue(): number;\n}\n","/** biome-ignore-all lint/suspicious/noExplicitAny: until I find a better way */\nimport { isKtList, type KtList, ktListToArray } from \"./ktListToArray\";\nimport { isKtLong, type KtLong, ktLongToNumber } from \"./ktLongToNumber\";\n\nexport type KtToJs<T> = T extends (...args: unknown[]) => unknown\n  ? T\n  : T extends { toJs: () => infer U }\n    ? KtToJs<U>\n    : T extends KtList<infer U>\n      ? KtToJs<U>[]\n      : T extends KtLong\n        ? number\n        : T extends (infer E)[]\n          ? KtToJs<E>[]\n          : T extends\n                | Date\n                | RegExp\n                | Map<unknown, unknown>\n                | Set<unknown>\n                | ArrayBuffer\n                | DataView\n                | Int8Array\n                | Uint8Array\n                | Uint8ClampedArray\n                | Int16Array\n                | Uint16Array\n                | Int32Array\n                | Uint32Array\n                | Float32Array\n                | Float64Array\n            ? T\n            : T extends object\n              ? { -readonly [K in keyof T]: KtToJs<T[K]> }\n              : T;\n\nexport function ktToJs<T>(data: T): KtToJs<T> {\n  if (data === null || typeof data !== \"object\") {\n    return data as any;\n  }\n\n  if (\"toJs\" in data && typeof data.toJs === \"function\") {\n    return ktToJs(data.toJs()) as any;\n  }\n\n  if (isKtList(data)) {\n    const jsArray = ktListToArray(data);\n    return jsArray.map((item) => ktToJs(item)) as any;\n  }\n\n  if (isKtLong(data)) {\n    return ktLongToNumber(data) as any;\n  }\n\n  if (Array.isArray(data)) {\n    return data.map((item) => ktToJs(item)) as any;\n  }\n\n  if (\n    data instanceof Date ||\n    data instanceof RegExp ||\n    data instanceof Map ||\n    data instanceof Set ||\n    data instanceof ArrayBuffer ||\n    ArrayBuffer.isView(data as any)\n  ) {\n    return data as any;\n  }\n\n  const obj = data as Record<string, unknown>;\n  for (const key of Object.keys(obj)) {\n    const value = obj[key];\n    obj[key] = ktToJs(value as any);\n  }\n  return obj as any;\n}\n","import type { NetworkError, Result } from \"@bill/Bill-shoppingList\";\n\nexport function handleResponseError<R>(response: Result<R, NetworkError>) {\n  if (\"error\" in response) {\n    throw new Error(response as unknown as string);\n  }\n}\n","import type { NetworkError, Result } from \"@bill/Bill-shoppingList\";\n\nimport { ktToJs } from \"~/utils/ktToJs\";\n\nexport function handleResponseSuccess<R>(response: Result<R, NetworkError>) {\n  if (!(\"result\" in response)) {\n    throw new Error(`Unsupported response type: ${response.constructor.name}`);\n  }\n\n  return ktToJs(response.result as R);\n}\n","import type { NetworkError, Result } from \"@bill/Bill-shoppingList\";\n\nimport { handleResponseError } from \"~/utils/handleResponseError\";\nimport { handleResponseSuccess } from \"~/utils/handleResponseSuccess\";\n\nexport function readResponse<R>(response: Result<R, NetworkError>) {\n  handleResponseError(response);\n\n  return handleResponseSuccess(response);\n}\n"],"names":["DEBOUNCE_DEFAULTS","debounce","fn","wait","options","leadingValue","timeout","resolveList","currentPromise","trailingArgs","applyFn","_this","args","_applyPromised","promise","resolve","shouldCallNow","_resolve","useAsyncData","autoKey","_isAutoKeyNeeded","_key","_handler","key","computed","toValue","nuxtApp","useNuxtApp","getDefault","getDefaultCachedData","asyncDataDefaults","initialFetchOptions","createAsyncData","asyncData","initialFetch","fetchOnServer","unregister","key2","data","instance","getCurrentInstance","cbs","onBeforeMount","cb","onUnmounted","isWithinClientOnly","inject","clientOnlySymbol","hasScope","getCurrentScope","unsubExecute","watch","newKey","oldKey","hasRun","isRunning","initialFetchOptions2","value","onScopeDispose","asyncReturn","writableComputedRef","args2","clearNuxtDataByKey","asyncDataPromise","getter","ref2","keyOrFetcher","fetcher","useNuxtData","unref","pick","obj","keys","newObj","initialCachedData","hasCustomGetCachedData","handler","_ref","ref","shallowRef","hasCachedData","unsubRefreshAsyncData","toRef","_opts","newValue","opts","cachedData","reject","err","_result","result","error","createError","nextTick","ctx","isNil","useOptimisticUpdatedList","listToSync","disableAction","blockAction","id","action","releaseAction","actions","_action","hasAction","channelActionsIterator","channelActions","isActionBlocked","getItem","index","getItemIndex","p","upsertItem","item","overwrite","foundItemIndex","itemIndex","deletedCount","itemToInsert","deleteItem","itemId","newData","evaluatedData","shoppingListClient","ShoppingListClient","productClient","ProductClient","categoryClient","CategoryClient","CHANNEL_ACTION","getChannelActionFrom","payload","assertValueIsDefined","ktListToArray","list","isKtList","ktLongToNumber","long","isKtLong","ktToJs","handleResponseError","response","handleResponseSuccess","readResponse"],"mappings":"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","x_google_ignoreList":[0,1]}